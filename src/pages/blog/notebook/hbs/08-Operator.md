---
title: 08-操作符
image: /img/hbs.png
date: 2020-12-28 17:02:27
description: JavaScript 操作符
---

[[toc]]

## 一元操作符

只操作一个值的操作符

### 自增自减（++ | --）

对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值

对于字符串，如果不是有效的数值形式，则将变量的值设置为 `NaN`。变量类型从字符串变成数值

对于布尔值，如果是 `false`，则转换为 0 再应用改变。变量类型从布尔值变成数值

对于布尔值，如果是 `true`，则转换为 1 再应用改变。变量类型从布尔值变成数值

对于浮点值，加 1 或减 1

如果是对象，则调用其 `valueOf()` 方法取得可以操作的值。对得到的值应用上述规则。如果是 `NaN`，则调用 `toString()` 并再次应用其他规则。变量类型从对象变成数值

```js
let a = 1;
let b = a++; 
//===> b = a = 1, a = a + 1 = 2（减同理）
let c = 1;
let d = ++c;
//===> d = c + 1 = 2, c = c + 1 = 2（减同理）
```

### 一元加减

一元加由一个加号（`+`）表示，放在变量前头，对**数值**没有任何影响

应用到非数值，则会执行与使用 `Number()` 转型函数一样的类型转换

一元减由一个减号（`-`）表示，放在变量前头，主要用于把数值变成负值

应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负值

## 位操作符

`ECMAScript `中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为 32 位整数，再进行位操作，之后再把结果转换为 64 位。对开发者而言，就好像只有 32 位整数一样，因 为 64 位整数存储格式是不可见的。既然知道了这些，就**只需要考虑 32 位整数**即可

有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这 一位称为符号位（`sign bit`），它的值决定了数值其余部分的格式

**正值**以**真正的二进制格式存储**，即 31 位中的每一位都代表 2 的幂

**负值**以一种称为二补数（或**补码**）的二进制编码存储(**对应正数按位取反之后加一**)

在**处理有符号整数时，我们无法访问第 31 位**

`ECMAScript `会帮我们记录这些信息。在把负值输出为一个二进制字符串时，我们会得到一个前面加了减号的绝对值

```js
let num = -18;
console.log(num.toString(2));
// "-10010" 转换过程会求得补码，然后再以更符合逻辑的形式表示出来
```

默认情况下，`ECMAScript` 中的**所有整数都表示为有符号数**

对无符号整数来说，第 32 位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了

**特殊值 `NaN` 和 `Infinity` 在位操作中都会被当成 0 处理**

如果将位操作符应用到非数值，那么首先会使用 `Number()` 函数将该值转换为数值（这个过程是自动的），然后再应用位操作。最终结果是数值

**位操作比普通操作符快得多**

### 按位非(`~`)

返回数值的一补数（<span class="text-red-600 font-bold">取反减一</span>）

```js
let num1 = 25; // 二进制 00000000000000000000000000011001
let num2 = ~num1; // 二进制 11111111111111111111111111100110
console.log(num2); // -26 
```

### 按位与(`&`)

将两个数的每一个位对齐， 然后基于真值表中的规则，对每一位执行相应的与操作

```js
let result = 25 & 3;
console.log(result); // 1 
////////////////////////////////////
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
AND = 0000 0000 0000 0000 0000 0000 0000 0001 
```

### 按位或(`|`)

将两个数的每一个位对齐， 然后基于真值表中的规则，对每一位执行相应的或操作

```js
let result = 25 | 3;
console.log(result); // 27 
////////////////////////////////////
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
 OR = 0000 0000 0000 0000 0000 0000 0001 1011 
```

### 按位异或(`^`)

将两个数的每一个位对齐， 然后基于真值表中的规则，对每一位执行相应的异或操作

```js
let result = 25 ^ 3;
console.log(result); // 26 
///////////////////////////////////
 25 = 0000 0000 0000 0000 0000 0000 0001 1001
  3 = 0000 0000 0000 0000 0000 0000 0000 0011
---------------------------------------------
XOR = 0000 0000 0000 0000 0000 0000 0001 1010 
```

### 左移操作符(`<<`)

会按照指定的位数将数值的所有位向左移动，**右边补 0**

```js
2 << 5
////////////////////////////////////////////////////////
2 === 0b0010
// << 5
0b01000000 === 2 ** (5 + 1) === 64
```



### 有符号右移操作符(`>>`)

**保留符号位**，其余右移，空位补 0

```js
// 有符号数保留符号位
64 >> 5 === 2
64 >> 6 === 1
64 >> 7 === 0
// ...
64 >> n === 0 // n ∈ [7, 31], >> 32 === >> 0
////////////////////////////////////////////////////////
64 === 0b01000000
// >> 5
0b0010 === 64 ** (1 / (5 + 1)) === 2

// 有符号数保留符号位
-64 >> 5 === -2
-64 >> 6 === -1
-64 >> 7 === -1
// ...
-64 >> n === -1 // n ∈ [7, 31], >> 32 === >> 0
```

### 无符号右移(`>>>`)

会将数值的所有 32 位都向右移，对正数没有影响

**不保留符号位，对负数影响很大**

## 布尔操作符

### 逻辑非（`!`）

可应用给 `ECMAScript` 中的任何值

这个操作符始终返回布尔值，无论应用到的是什么数据类型

逻辑非操作符**首先将操作数转换为布尔值，然后再对其取反**

转换规则：
  - 如果操作数是对象，则返回 `false`
  - 如果操作数是空字符串，则返回 `true`
  - 如果操作数是非空字符串，则返回 `false`
  - 如果操作数是数值 0，则返回 `true`
  - 如果操作数是非 0 数值（包括 `Infinity`），则返回 `false`
  - 如果操作数是 `null`，则返回 `true`
  - 如果操作数是 `NaN`，则返回 `true`
  - 如果操作数是 `undefined`，则返回 `true`

同时使用两个叹号（`!!`），相当于调用了转型函数 `Boolean()`

```js
console.log(!false); // true
console.log(!"blue"); // false
console.log(!0); // true
console.log(!NaN); // true
console.log(!""); // true
console.log(!12345); // false 
//////////////////////////////////////
console.log(!!"blue"); // true
console.log(!!0); // false
console.log(!!NaN); // false
console.log(!!""); // false
console.log(!!12345); // true
```

### 逻辑与(`&&`)

逻辑与操作符可用于任何类型的操作数，不限于布尔值

如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值，而是遵循如下规则：

- **如果第一个操作数是对象，则返回第二个操作数**
- 如果第二个操作数是对象，则只有第一个操作数求值为 `true` 才会返回该对象
- 如果两个操作数都是对象，则返回第二个操作数
- **如果有一个操作数是 `null`，则返回 `null`**
- **如果有一个操作数是 `NaN`，则返回 `NaN`**
- **如果有一个操作数是 `undefined`，则返回 `undefined`**

### 逻辑或(`||`)

与逻辑与类似，如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如下规则：
  - 如果第一个操作数是对象，则返回第一个操作数
  - 如果第一个操作数求值为 `false`，则返回第二个操作数
  - 如果两个操作数都是对象，则返回第一个操作数
  - **如果两个操作数都是 `null`，则返回 `null`**
  - **如果两个操作数都是 `NaN`，则返回 `NaN`**
  - **如果两个操作数都是 `undefined`，则返回 `undefined`**

## 乘性操作符

### 乘法操作符(`*`)

乘法操作符由一个星号（`*`）表示，可以用于计算两个数值的乘积

特殊的行为：
  - 如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值
  - 如果 `ECMAScript` 不能表示乘积，则返回 `Infinity` 或 `-Infinity`
  - **如果有任一操作数是 `NaN`，则返回 `NaN`**
  - **如果是 `Infinity` 乘以 0，则返回 `NaN`**
  - 如果是 `Infinity` 乘以非 0 的有限数值，则根据第二个操作数的符号返回 `Infinity` 或 `-Infinity`
  - **如果是 `Infinity` 乘以 `Infinity`，则返回 `Infinity`**
  - 如果有**不是数值的操作数，则先在后台用 `Number()` 将其转换为数值**，然后再应用上述规则

### 除法操作符(`/`)

除法操作符由一个斜杠（`/`）表示，用于计算第一个操作数除以第二个操作数的商

特殊的行为：
  - 如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值
  - 如果 `ECMAScript` 不能表示商，则返回 `Infinity` 或 `-Infinity`
  - 如果有任一操作数是 `NaN`，则返回 `NaN`
  - **如果是 `Infinity` 除以 `Infinity`，则返回 `NaN`**
  - **如果是 0 除以 0，则返回 `NaN`**
  - 如果是**非 0 的有限值除以 0，则根据第一个操作数的符号返回 `Infinity` 或 `-Infinity`**
  - 如果是 `Infinity` 除以任何数值，则根据第二个操作数的符号返回 `Infinity` 或 `-Infinity`
  - 如果有不是数值的操作数，则先在后台用 `Number()` 函数将其转换为数值，然后再应用上述规则

### 取模操作符(`%`)

取模（余数）操作符由一个百分比符号（`%`）表示

特殊的行为：
  - 如果操作数是数值，则执行常规除法运算，返回余数
  - 如果被除数是无限值，除数是有限值，则返回 `NaN`
  - 如果被除数是有限值，除数是 0，则返回 `NaN`
  - 如果是 `Infinity` 除以 `Infinity`，则返回 `NaN`
  - 如果被除数是有限值，除数是无限值，则返回被除数
  - 如果被除数是 0，除数不是 0，则返回 0
  - 如果有不是数值的操作数，则先在后台用 `Number()` 函数将其转换为数值，然后再应用上述规则

### 指数操作符(`**`)

`Math.pow(3, 2) ===> 3 ** 2`

指数赋值操作符 `a **= 2 ===> a = a ** 2`

## 加性操作符

### 加法操作符(`+`)

加法操作符（`+`）用于求两个数的和

如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：
  - 如果有任一操作数是 `NaN`，则返回 `NaN`
  - 如果是 `Infinity` 加 `Infinity`，则返回 `Infinity`
  - 如果是`-Infinity` 加 `-Infinity`，则返回 `-Infinity`
  - **如果是 `Infinity` 加 `-Infinity`，则返回 `NaN`**
  - 如果是 `+0` 加 `+0`，则返回 `+0`
  - 如果是 `-0` 加 `+0`，则返回 `+0`
  - 如果是 `-0` 加 `-0`，则返回 `-0`

如果有一个操作数是字符串，则要应用如下规则：
  - 如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面
  - 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起

如果有任一操作数是对象、数值或布尔值，则调用它们的 `toString()` 方法以获取字符串，然后再应用前面的关于字符串的规则

对于 `undefined` 和 `null`，则调用 `String()` 函数，分别获取 `"undefined"` 和 `"null"`

### 减法操作符(`-`)

规则：
  - 如果两个操作数都是数值，则执行数学减法运算并返回结果
  - 如果有任一操作数是 `NaN`，则返回 `NaN`
  - 如果是 `Infinity` 减 `Infinity`，则返回 `NaN`
  - 如果是 `-Infinity` 减 `-Infinity`，则返回 `NaN`
  - 如果是 `Infinity` 减 `-Infinity`，则返回 `Infinity`
  - 如果是`-Infinity` 减  `Infinity`，则返回 `-Infinity`
  - 如果是 `+0` 减 `+0`，则返回 `+0`
  - 如果是 `+0` 减 `-0`，则返回 `-0`
  - 如果是 `-0` 减 `-0`，则返回 `+0`
  - 如果有任一操作数是字符串、布尔值、`null` 或 `undefined`，则先在后台使用 `Number()` 将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 `NaN`，则减法计算的结果是 `NaN`
  - 如果有任一操作数是对象，则调用其 `valueOf()` 方法取得表示它的数值。如果该值是 `NaN`，则减法计算的结果是 `NaN`。如果对象没有 `valueOf()` 方法，则调用其 `toString()` 方法，然后再将得到的字符串转换为数值

```js
let result1 = 5 - true; // true 被转换为 1，所以结果是 4
let result2 = NaN - 1; // NaN
let result3 = 5 - 3; // 2
let result4 = 5 - ""; // ""被转换为 0，所以结果是 5
let result5 = 5 - "2"; // "2"被转换为 2，所以结果是 3
let result6 = 5 - null; // null 被转换为 0，所以结果是 5 
```



## 关系操作符

`< > <= >=` 符执行比较两个值的操作，返回布尔值

不同数据类型转换规则：
  - 如果操作数**都是数值，则执行数值比较**
  - 如果操作数**都是字符串，则逐个比较字符串中对应字符的编码(大写字母的编码都小于小写字母的编码)**
  - 如果有**任一操作数是数值，则将另一个操作数转换为数值，执行数值比较**
  - 如果有任一操作数是对象，则调用其 `valueOf()` 方法，取得结果后再根据前面的规则执行比较；如果没有 `valueOf()` 操作符，则调用 `toString()` 方法，取得结果后再根据前面的规则执行比较
  - 如果有**任一操作数是布尔值，则将其转换为数值再执行比较**

## 相等操作符

### 等于和不等于

等于操作符用两个等于号（`==`）表示，如果操作数相等，则会返回 `true`

不等于操作符用叹号和等于号（`!=`）表示，如果两个操作数不相等，则会返回 `true`

这两个操作符都会先进行类型转换（通常称为**强制类型转换**）再确定操作数是否相等

转换规则：
  - 如果任一操作数是布尔值，则将其转换为数值再比较是否相等。`false` 转换为 0，`true` 转换为 1
  - 如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等
  - 如果一个操作数是对象，另一个操作数不是，则调用对象的 `valueOf()` 方法取得其原始值，再根据前面的规则进行比较
  - **`null` 和 `undefined` 相等**
  - `null` 和 `undefined` **不能转换为其他类型的值**再进行比较
  - **如果有任一操作数是 `NaN`，则相等操作符返回 `false`，不相等操作符返回 `true`**
  - 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象， 则相等操作符返回 `true`。否则，两者不相等

```js
null == undefined 	// true
"NaN" == NaN 		// false
5 == NaN 			// false
NaN == NaN 			// false
NaN != NaN 			// true
false == 0 			// true
true == 1 			// true
true == 2 			// false
undefined == 0 		// false
null == 0 			// false
"5" == 5 			// true
```

### 全等和不全等

**不执行类型转换**，只有两个操作数在不转换的前提下相等才返回 `true`

## 条件操作符(三元运算符)

`variable = boolean_expression ? true_value : false_value;`

## 赋值操作符

`=`

`*=`

`/=`

`%=`

`+=`

`-=`

`<<=`

`>>=`

`>>>=`

**仅为简写语法，不会提升性能**

## 逗号操作符

可以用来在一条语句中执行多个操作

在**赋值**时使用逗号操作符分隔值，**最终会返回表达式中最后一个值**

`let num = (5, 1, 4, 8, 0); // num 的值为 0 `