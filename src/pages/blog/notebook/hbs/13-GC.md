---
title: 13-垃圾回收
image: /img/hbs.png
description: JavaScript 垃圾回收
date: 2020-12-28 17:25:43
---

[[toc]]

## 概述

`JavaScript` 是使用**自动垃圾回收**的语言，也就是说**执行环境负责在代码执行时管理内存**

基本思路：**确定哪个变量不会再使用，然后释放它占用的内存**

这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行

垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的

我们以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局部 变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略：**标记清理**和**引用计数**

## 标记清理

当变量进入上下文，比如在函数内部声明一个变量时，这个变量会被加上存在于上下文中的标记

而在上下文中的变量，逻辑上讲，永远不应该释放它们的内存，因为只要上下文中的代码在运行，就有可能用到它们

当变量离开上下文时， 也会被加上离开上下文的标记

给变量加标记的方式有很多种。比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表。**标记过程的实现并不重要，关键是策略**

垃圾回收程序运行的时候，会标记内存中存储的所有变量（**标记方法有很多种**）。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存

到了 2008 年，`IE`、`Firefox`、`Opera`、`Chrome` 和 `Safari` 都在自己的 `JavaScript` 实现中采用标记清理（或其变体），只是在运行垃圾回收的频率上有所差异

## 引用计数

声明变量并给它赋一个引用值时，这个值的引用数为 1

如果同一个值又被赋给另一个变量，那么引用数加 1

类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减 1

**当一个值的引用数为 0 时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了**

垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存

引用计数最早由 `Netscape Navigator 3.0` 采用，但很快就遇到了严重的问题：**循环引用**

为此，`Netscape` 在 4.0 版放弃了引用计数，转而采用标记清理

`IE8` 及更早版本的 `IE` 中，并非所有对象都是原生 `JavaScript` 对象。`BOM` 和 `DOM` 中的对象是 `C++` 实现的组件对象模型（`COM，Component Object Model`）对象，而 `COM` 对象使用引用计数实现垃圾回收。因此，即使这些版本 `IE` 的 `JavaScript` 引擎使用标记清理，`JavaScript` 存取的 `COM` 对象依旧使用引用计数。换句话说，**只要涉及 `COM` 对象，就无法避开循环引用问题**

为避免类似的循环引用问题，应该**在确保不使用的情况下切断原生 `JavaScript` 对象与 `DOM` 元素之间的连接(把变量值设置为`null`)**

为了补救这一点，`IE9` 把 `BOM` 和 `DOM` 对象都改成了 `JavaScript` 对象，这同时也避免了由于存在两套垃圾回收算法而导致的问题，还消除了常见的内存泄漏现象

## 性能

垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要

尤其是在内存有限的移动设备上，垃圾回收有可能会明显拖慢渲染的速度和帧速率

开发者不知道什么时候运行时会收集垃圾，因此最好的办法是在写代码时就要做到：无论什么时候开始收集垃圾，都能让它尽快结束工作

现代垃圾回收程序会基于对 `JavaScript` 运行时环境的探测来决定何时运行。探测机制因引擎而异， 但基本上都是根据已分配对象的大小和数量来判断的

由于调度垃圾回收程序方面的问题会导致性能下降，`IE` 曾饱受诟病(分配一些固定值，只要达到某一阈值就进行垃圾回收；导致垃圾回收程序过于频繁的运行)

由于对性能的严重影响，`IE7` 最终更新了垃圾回收程序(起始阈值同 `IE6`，根据实时情况动态调整)

在某些浏览器中是有可能（但不推荐）主动触发垃圾回收的。在 `IE` 中，`window. CollectGarbage()` 方法会立即触发垃圾回收。在 `Opera 7` 及更高版本中，调用 `window. opera.collect()` 也会启动垃圾回收程序

## 内存管理

将内存占用量保持在一个较小的值可以让页面性能更好

优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据

如果数据不再必要，那么把它设置为 `null`，从而释放其引用(解除引用，适合全局变量和全局对象的属性)

局部变量在超出作用域后会被自动解除引用

使用 `let` 和 `const` 代替 `var` 可尽早回收

### 隐藏类与删除

`V8` 会将创建的对象与隐藏类关联起来，以跟踪它们的属性特征

能够共享相同隐藏类的对象性能会更好，`V8` 会针对这种情况进行优化

如果动态添加或删除属性则会导致原本共享的隐藏类不再共享

不再使用的属性最好设为 `null`，而不是直接 `delete`

### 内存泄漏

**意外声明的全局变量**

**被遗忘的定时器**

**闭包**

### 静态分配

如果一个函数中有使用 `new` 创建类实例的步骤，当这个函数被频繁调用时，垃圾回收程序也会频繁被启用

此时可在函数外部创建对象池，用来管理一组可回收的对象

静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但这种情况并不多见，大多数情况下，这都属于过早优化，因此不用考虑